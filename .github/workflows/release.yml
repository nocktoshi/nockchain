name: Release Binaries and Generate Manifests

on:
  push:
    branches: ["master", "nightly"]
    tags: ["v*"]
  pull_request:
    branches: ["master", "nightly"]

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            use_zigbuild: false
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            use_zigbuild: true
          - os: macos-latest
            target: aarch64-apple-darwin
            use_zigbuild: false
    permissions:
      contents: write  # Required for action-gh-release
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine channel
        id: channel
        run: |
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            echo "channel=stable" >> $GITHUB_OUTPUT
            echo "version=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref_name }}" == "master" ]]; then
            echo "channel=stable" >> $GITHUB_OUTPUT
            SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
            echo "version=${SHORT_SHA}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref_name }}" == "nightly" ]]; then
            echo "channel=nightly" >> $GITHUB_OUTPUT
            DATE=$(date +%Y%m%d)
            echo "version=${DATE}" >> $GITHUB_OUTPUT
          else
            echo "channel=dev" >> $GITHUB_OUTPUT
            SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
            echo "version=${SHORT_SHA}" >> $GITHUB_OUTPUT
          fi
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "channel=pr" >> $GITHUB_OUTPUT
            echo "version=pr-${{ github.event.number }}" >> $GITHUB_OUTPUT
          fi

      - name: Extract Cargo versions
        id: cargo-versions
        run: |
          # Get workspace version - simpler approach
          HOON_VERSION=$(sed -n '/\[workspace.package\]/,/\[/p' Cargo.toml | grep '^version' | cut -d'"' -f2)
          
          # Get hoonc version
          HOONC_VERSION=$(grep '^version' crates/hoonc/Cargo.toml | cut -d'"' -f2)
          
          # Get nockup version  
          NOCKUP_VERSION=$(grep '^version' crates/nockup/Cargo.toml | cut -d'"' -f2)
          
          # Get nockchain version
          NOCKCHAIN_VERSION=$(grep '^version' crates/nockchain/Cargo.toml | cut -d'"' -f2)
          
          # For nightly, append date
          if [[ "${{ steps.channel.outputs.channel }}" == "nightly" ]]; then
            DATE=$(date +%Y%m%d)
            HOON_VERSION="${HOON_VERSION}-${DATE}"
            HOONC_VERSION="${HOONC_VERSION}-${DATE}"
            NOCKUP_VERSION="${NOCKUP_VERSION}-${DATE}"
            NOCKCHAIN_VERSION="${NOCKCHAIN_VERSION}-${DATE}"
          fi
          
          # Debug output
          echo "HOON_VERSION='$HOON_VERSION'"
          echo "HOONC_VERSION='$HOONC_VERSION'"
          echo "NOCKUP_VERSION='$NOCKUP_VERSION'"
          echo "NOCKCHAIN_VERSION='$NOCKCHAIN_VERSION'"
          
          # Validate versions
          if [[ -z "$HOON_VERSION" || -z "$HOONC_VERSION" || -z "$NOCKUP_VERSION" || -z "$NOCKCHAIN_VERSION" ]]; then
            echo "Error: Missing version in one or more Cargo.toml files"
            exit 1
          fi
          
          echo "hoon_version=$HOON_VERSION" >> $GITHUB_OUTPUT
          echo "hoonc_version=$HOONC_VERSION" >> $GITHUB_OUTPUT
          echo "nockup_version=$NOCKUP_VERSION" >> $GITHUB_OUTPUT
          echo "nockchain_version=$NOCKCHAIN_VERSION" >> $GITHUB_OUTPUT
          echo "Extracted versions: hoon=$HOON_VERSION, hoonc=$HOONC_VERSION, nockup=$NOCKUP_VERSION, nockchain=$NOCKCHAIN_VERSION"

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@nightly
        with:
          targets: ${{ matrix.target }}

      - name: Install Zig and cargo-zigbuild
        if: matrix.use_zigbuild
        run: |
          # Install Zig
          wget -q https://ziglang.org/download/0.13.0/zig-linux-x86_64-0.13.0.tar.xz
          tar -xf zig-linux-x86_64-0.13.0.tar.xz
          sudo mv zig-linux-x86_64-0.13.0 /usr/local/zig
          sudo ln -s /usr/local/zig/zig /usr/local/bin/zig
          zig version
          
          # Install cargo-zigbuild
          cargo install --locked cargo-zigbuild

          # Add target
          rustup target add ${{ matrix.target }}

      - name: Install Protocol Buffers compiler (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y protobuf-compiler

      - name: Install Protocol Buffers compiler (macOS)
        if: runner.os == 'macOS'
        run: brew install protobuf

      - name: Cache Rust dependencies
        uses: swatinem/rust-cache@v2
        with:
          key: ${{ matrix.target }}

      - name: Install required tools for manifest generation
        run: |
          # Install blake3 hash tool from pre-built binaries
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            wget -q https://github.com/BLAKE3-team/BLAKE3/releases/download/1.5.0/b3sum_linux_x64_bin -O b3sum
            chmod +x b3sum
            sudo mv b3sum /usr/local/bin/
            sudo apt-get update
            sudo apt-get install -y jq
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            brew install b3sum jq
          fi

      - name: Install cross-compilation dependencies
        if: matrix.use_zigbuild
        run: |
          # Install perl (needed for OpenSSL build)
          sudo apt-get update
          sudo apt-get install -y perl

      # Stage 1a: Build native hoonc for .jam generation (cross-compile only)
      - name: Build hoonc-native (for .jam generation)
        if: matrix.use_zigbuild == true
        run: |
          echo "Building native x86_64 hoonc for .jam generation..."
          cargo build --release --bin hoonc --manifest-path crates/hoonc/Cargo.toml --locked
          # Save it with a different name
          cp target/release/hoonc target/release/hoonc-native
          file target/release/hoonc-native

      # Stage 1b: Build hoon (all platforms)
      - name: Build hoon
        env:
          CC: ${{ matrix.use_zigbuild && 'zig cc -target aarch64-linux-gnu' || '' }}
          CXX: ${{ matrix.use_zigbuild && 'zig c++ -target aarch64-linux-gnu' || '' }}
          AR: ${{ matrix.use_zigbuild && 'zig ar' || '' }}
        run: |
          if [[ "${{ matrix.use_zigbuild }}" == "true" ]]; then
            cargo zigbuild --release --bin hoon --manifest-path crates/hoon/Cargo.toml --locked --target ${{ matrix.target }}
            file target/${{ matrix.target }}/release/hoon
          else
            cargo build --release --bin hoon --manifest-path crates/hoon/Cargo.toml --locked
            file target/release/hoon
          fi

      # Stage 1c: Build hoonc for target platform
      - name: Build hoonc (target)
        env:
          CC: ${{ matrix.use_zigbuild && 'zig cc -target aarch64-linux-gnu' || '' }}
          CXX: ${{ matrix.use_zigbuild && 'zig c++ -target aarch64-linux-gnu' || '' }}
          AR: ${{ matrix.use_zigbuild && 'zig ar' || '' }}
        run: |
          if [[ "${{ matrix.use_zigbuild }}" == "true" ]]; then
            cargo zigbuild --release --bin hoonc --manifest-path crates/hoonc/Cargo.toml --locked --target ${{ matrix.target }}
            file target/${{ matrix.target }}/release/hoonc
          else
            cargo build --release --bin hoonc --manifest-path crates/hoonc/Cargo.toml --locked
            file target/release/hoonc
          fi

      # Stage 2: Generate .jam files using native hoonc
      - name: Generate .jam assets
        run: |
          # Use the appropriate hoonc for .jam generation
          if [[ "${{ matrix.use_zigbuild }}" == "true" ]]; then
            # Cross-compile: use native hoonc
            HOONC_PATH="target/release/hoonc-native"
            echo "Using native hoonc for .jam generation: $HOONC_PATH"
          else
            # Native build: use regular hoonc
            HOONC_PATH="target/release/hoonc"
            echo "Using regular hoonc for .jam generation: $HOONC_PATH"
          fi
          
          # Make hoonc available in PATH
          export PATH="$(dirname $(readlink -f $HOONC_PATH)):$PATH"
          
          # Verify hoonc works
          hoonc --version
          
          # Generate .jam files using Makefile
          mkdir -p assets hoon
          make assets/dumb.jam assets/miner.jam assets/wal.jam assets/peek.jam
          
          # Verify they were created
          ls -lah assets/*.jam

      - name: Build nockup (Stage 3 - independent)
        env:
          CC: ${{ matrix.use_zigbuild && 'zig cc -target aarch64-linux-gnu' || '' }}
          CXX: ${{ matrix.use_zigbuild && 'zig c++ -target aarch64-linux-gnu' || '' }}
          AR: ${{ matrix.use_zigbuild && 'zig ar' || '' }}
        run: |
          if [[ "${{ matrix.use_zigbuild }}" == "true" ]]; then
            cargo zigbuild --release --bin nockup --manifest-path crates/nockup/Cargo.toml --target ${{ matrix.target }} --features vendored-openssl
            file target/${{ matrix.target }}/release/nockup
          else
            cargo build --release --bin nockup --manifest-path crates/nockup/Cargo.toml --locked
            file target/release/nockup
          fi

      - name: Build nockchain (Stage 3 - needs .jam files)
        env:
          CC: ${{ matrix.use_zigbuild && 'zig cc -target aarch64-linux-gnu' || '' }}
          CXX: ${{ matrix.use_zigbuild && 'zig c++ -target aarch64-linux-gnu' || '' }}
          AR: ${{ matrix.use_zigbuild && 'zig ar' || '' }}
        run: |
          if [[ "${{ matrix.use_zigbuild }}" == "true" ]]; then
            cargo zigbuild --release --bin nockchain --manifest-path crates/nockchain/Cargo.toml --target ${{ matrix.target }}
            file target/${{ matrix.target }}/release/nockchain
          else
            cargo build --release --bin nockchain --manifest-path crates/nockchain/Cargo.toml --locked
            file target/release/nockchain
          fi

      - name: Build nockchain-wallet
        env:
          CC: ${{ matrix.use_zigbuild && 'zig cc -target aarch64-linux-gnu' || '' }}
          CXX: ${{ matrix.use_zigbuild && 'zig c++ -target aarch64-linux-gnu' || '' }}
          AR: ${{ matrix.use_zigbuild && 'zig ar' || '' }}
        run: |
          if [[ "${{ matrix.use_zigbuild }}" == "true" ]]; then
            cargo zigbuild --release --bin nockchain-wallet --manifest-path crates/nockchain-wallet/Cargo.toml --target ${{ matrix.target }}
            file target/${{ matrix.target }}/release/nockchain-wallet
          else
            cargo build --release --bin nockchain-wallet --manifest-path crates/nockchain-wallet/Cargo.toml --locked
            file target/release/nockchain-wallet
          fi

      - name: Set up GPG
        if: runner.os == 'Linux' && github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/nightly' || github.ref_type == 'tag')
        run: |
          # Import GPG private key
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | tr -d '\n' | base64 -d | gpg --batch --import
          # Configure GPG for non-interactive use
          echo "use-agent" >> ~/.gnupg/gpg.conf
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "batch" >> ~/.gnupg/gpg.conf
          # Get the full fingerprint and trust the key
          FINGERPRINT=$(gpg --list-secret-keys --with-colons | grep '^fpr:' | head -1 | cut -d: -f10)
          echo "${FINGERPRINT}:6:" | gpg --import-ownertrust
          # Verify key is available
          gpg --list-secret-keys

      - name: Package and sign binaries
        run: |
          mkdir -p dist
          CHANNEL="${{ steps.channel.outputs.channel }}"
          SHOULD_SIGN="${{ runner.os == 'Linux' && github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/nightly' || github.ref_type == 'tag') }}"
          
          if [[ "$CHANNEL" == "pr" ]]; then
            echo "Skipping packaging for PRs"
            exit 0
          fi
          
          # Determine binary directory based on build method
          if [[ "${{ matrix.use_zigbuild }}" == "true" ]]; then
            BINARY_DIR="target/${{ matrix.target }}/release"
          else
            BINARY_DIR="target/release"
          fi
          
          # Package each binary: sign it, then include both binary and .asc in tarball
          for binary in hoon hoonc nockup nockchain nockchain-wallet; do
            if [ -f "$BINARY_DIR/$binary" ]; then
              cp "$BINARY_DIR/$binary" dist/$binary
              chmod +x dist/$binary
              
              # Sign the binary if this is a release build
              if [[ "$SHOULD_SIGN" == "true" ]]; then
                echo "${{ secrets.GPG_PASSPHRASE }}" | gpg --batch --yes --passphrase-fd 0 --pinentry-mode loopback --detach-sign --armor --default-key "${{ secrets.GPG_KEY_ID }}" dist/$binary
                echo "Created dist/$binary.asc"
                
                # Create tarball with both binary and signature
                tar -czf dist/${binary}-${{ matrix.target }}.tar.gz -C dist $binary ${binary}.asc
              else
                # No signing, just create tarball with binary
                tar -czf dist/${binary}-${{ matrix.target }}.tar.gz -C dist $binary
              fi
              
              echo "Created dist/${binary}-${{ matrix.target }}.tar.gz"
            else
              echo "Skipping $binary: binary missing at $BINARY_DIR/$binary"
            fi
          done
          
          echo "Packaged artifacts for channel $CHANNEL:"
          ls -la dist/

      - name: Generate individual manifests
        if: steps.channel.outputs.channel != 'pr'
        run: |
          mkdir -p scripts
          
          # Create manifest generation script
          cat << 'EOF' > scripts/generate-manifest.sh
          #!/bin/bash
          set -euo pipefail
          
          BINARY=$1
          TARGET=$2
          VERSION=$3
          COMMIT_SHA=${GITHUB_SHA:-$(git rev-parse HEAD)}
          COMMIT_SHORT=$(echo $COMMIT_SHA | cut -c1-7)
          DATE=$(date +%Y-%m-%d)
          
          # Calculate hashes from the packaged archive
          ARCHIVE_PATH="dist/${BINARY}-${TARGET}.tar.gz"
          
          if [ ! -f "$ARCHIVE_PATH" ]; then
              echo "Error: Archive not found at $ARCHIVE_PATH" >&2
              exit 1
          fi
          
          BLAKE3_HASH=$(b3sum "$ARCHIVE_PATH" | cut -d' ' -f1)
          SHA1_HASH=$(sha1sum "$ARCHIVE_PATH" 2>/dev/null | cut -d' ' -f1 || shasum -a 1 "$ARCHIVE_PATH" | cut -d' ' -f1)
          
          # Generate URL - using commit-based release tag
          URL="https://github.com/nockchain/nockchain/releases/download/build-$COMMIT_SHA/$BINARY-$TARGET.tar.gz"
          
          # Generate manifest
          cat << MANIFEST_EOF
          manifest-version = "1"
          date = "$DATE"
          commit = "$COMMIT_SHA"
          commit_short = "$COMMIT_SHORT"
          
          [pkg.$BINARY]
          version = "$VERSION"
          components = ["core"]
          
          [pkg.$BINARY.target.$TARGET]
          available = true
          url = "$URL"
          hash_blake3 = "$BLAKE3_HASH"
          hash_sha1 = "$SHA1_HASH"
          MANIFEST_EOF
          EOF
          
          chmod +x scripts/generate-manifest.sh
          
          # Get version for nockchain binaries (same for both)
          NOCKCHAIN_VERSION="${{ steps.cargo-versions.outputs.nockchain_version }}"
          
          # Generate manifests for each binary that was built
          for binary in hoon hoonc nockup nockchain nockchain-wallet; do
            if [ -f "dist/${binary}-${{ matrix.target }}.tar.gz" ]; then
              # Determine version based on binary name
              case "$binary" in
                hoon)
                  VERSION="${{ steps.cargo-versions.outputs.hoon_version }}"
                  ;;
                hoonc)
                  VERSION="${{ steps.cargo-versions.outputs.hoonc_version }}"
                  ;;
                nockup)
                  VERSION="${{ steps.cargo-versions.outputs.nockup_version }}"
                  ;;
                nockchain|nockchain-wallet)
                  VERSION="$NOCKCHAIN_VERSION"
                  ;;
              esac
              
              ./scripts/generate-manifest.sh $binary ${{ matrix.target }} "$VERSION" > "${binary}-${{ matrix.target }}-manifest.toml"
              echo "Generated manifest for $binary (version $VERSION)"
            fi
          done

      - name: Upload individual manifests
        if: steps.channel.outputs.channel != 'pr'
        uses: actions/upload-artifact@v4
        with:
          name: toolchains-${{ matrix.target }}
          path: "*-${{ matrix.target }}-manifest.toml"
          retention-days: 7

      - name: Upload release assets
        if: github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/nightly' || github.ref_type == 'tag')
        uses: softprops/action-gh-release@v1
        with:
          tag_name: build-${{ github.sha }}
          name: Build ${{ github.sha }}
          files: |
            dist/hoon-${{ matrix.target }}.tar.gz
            dist/hoonc-${{ matrix.target }}.tar.gz
            dist/nockup-${{ matrix.target }}.tar.gz
            dist/nockchain-${{ matrix.target }}.tar.gz
            dist/nockchain-wallet-${{ matrix.target }}.tar.gz

      - name: Clean up old releases
        if: github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/nightly' || github.ref_type == 'tag')
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Keep previous releases for the last N days instead of last N commits
          # This avoids issues with parallel merges and non-linear history
          KEEP_DAYS=28
          CUTOFF_DATE=$(date -u -d "$KEEP_DAYS days ago" +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-${KEEP_DAYS}d +%Y-%m-%dT%H:%M:%SZ)

          echo "Keeping releases created after: $CUTOFF_DATE"

          # Get all releases with their creation dates
          gh release list --limit 1000 --json tagName,createdAt | jq -r '.[] | "\(.tagName)|\(.createdAt)"' | while IFS='|' read -r release_tag created_at; do
            # Skip non-build tags
            if [[ ! "$release_tag" =~ ^build- ]]; then
              continue
            fi

            # Compare dates
            if [[ "$created_at" < "$CUTOFF_DATE" ]]; then
              echo "Deleting old release: $release_tag (created $created_at)"
              gh release delete "$release_tag" --yes || echo "Failed to delete $release_tag"
            else
              echo "Keeping recent release: $release_tag (created $created_at)"
            fi
          done

  collate-manifests:
    name: Collate Channel Manifests
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/nightly' || github.ref_type == 'tag')
    permissions:
        contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq
        
      - name: Download all manifest artifacts
        uses: actions/download-artifact@v4
        with:
          path: toolchains/
          pattern: toolchains-*
          merge-multiple: true
          
      - name: List downloaded manifests
        run: |
          echo "Downloaded manifests:"
          find toolchains/ -name "*.toml" -type f | sort
          
      - name: Create collation script
        run: |
          mkdir -p scripts
          cat << 'EOF' > scripts/collate-manifests.sh
          #!/bin/bash
          set -euo pipefail
          
          MANIFEST_DIR=$1
          COMMIT_SHA=${GITHUB_SHA:-$(git rev-parse HEAD)}
          COMMIT_SHORT=$(echo $COMMIT_SHA | cut -c1-7)
          
          # Get nockup version from the workspace
          NOCKUP_VERSION=$(grep '^version[[:space:]]*=' crates/nockup/Cargo.toml | sed 's/.*=[[:space:]]*"\([^"]*\)".*/\1/' | head -1)
          
          if [ -z "$NOCKUP_VERSION" ]; then
              echo "Error: Could not extract nockup version" >&2
              exit 1
          fi
          
          # Start with global metadata
          cat << HEADER_EOF
          manifest-version = "1"
          date = "$(date +%Y-%m-%d)"
          commit = "$COMMIT_SHA"
          commit_short = "$COMMIT_SHORT"
          
          # Global package info
          [pkg.nockup]
          version = "$NOCKUP_VERSION"
          components = ["core"]
          extensions = []
          
          # Profiles
          [profiles.default]
          components = ["core"]
          [profiles.minimal]
          components = ["core"]
          
          HEADER_EOF
          
          # Process manifests by package, then by target
          for package in nockup nockchain nockchain-wallet hoonc hoon; do
              echo "# $package binaries"
              
              # Find all manifests for this package
              find "$MANIFEST_DIR" -name "${package}-*-manifest.toml" -type f | sort | while read manifest; do
                  if [ -f "$manifest" ]; then
                      echo "# From $(basename "$manifest")"
                      # Extract only the target-specific sections
                      awk -v pkg="$package" '
                          /^\[pkg\./ { 
                              if ($0 ~ "\\[pkg\\." pkg "\\.target\\.") {
                                  printing = 1
                              } else {
                                  printing = 0
                              }
                          }
                          /^available|^url|^hash_/ { 
                              if (printing) print
                          }
                          /^\[pkg\..*\.target\./ {
                              if (printing) print
                          }
                      ' "$manifest"
                      echo ""
                  fi
              done
          done
          EOF
          
          chmod +x scripts/collate-manifests.sh
          
      - name: Collate manifests
        run: |
          ./scripts/collate-manifests.sh toolchains/ > nockchain-manifest.toml
          
      - name: Show final manifest
        run: |
          echo "=== Final nockchain manifest ==="
          cat nockchain-manifest.toml
          
      - name: Upload final manifest
        uses: actions/upload-artifact@v4
        with:
          name: nockchain-manifest
          path: nockchain-manifest.toml
          retention-days: 30
          
      - name: Add manifest to existing release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: build-${{ github.sha }}
          files: |
            nockchain-manifest.toml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}